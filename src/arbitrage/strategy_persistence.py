"""
Strategy Persistence Layer using SQLite
Ensures strategies survive container restarts on Railway
"""
import sqlite3
import json
import os
from datetime import datetime
from typing import Dict, List, Optional, Any
import logging

logger = logging.getLogger(__name__)

# Database file location (Railway volume mount)
DB_PATH = os.getenv('STRATEGY_DB_PATH', '/app/data/strategies.db')
# Fallback to local path if volume not mounted
if not os.path.exists(os.path.dirname(DB_PATH)):
    DB_PATH = 'data/strategies.db'
    os.makedirs('data', exist_ok=True)

def init_db():
    """Initialize the strategy persistence database"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS active_strategies (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            symbol TEXT NOT NULL UNIQUE,
            strategy_type TEXT NOT NULL,
            exchange TEXT NOT NULL,
            config JSON NOT NULL,
            started_at TEXT NOT NULL,
            last_active TEXT NOT NULL,
            status TEXT DEFAULT 'running',
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS strategy_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            symbol TEXT NOT NULL,
            strategy_type TEXT NOT NULL,
            exchange TEXT NOT NULL,
            started_at TEXT NOT NULL,
            stopped_at TEXT NOT NULL,
            reason TEXT,
            pnl REAL,
            trades_count INTEGER,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # Table for tracking signals generated by strategies
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS strategy_signals (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            symbol TEXT NOT NULL,
            strategy_type TEXT NOT NULL,
            signal_type TEXT NOT NULL,          -- 'BUY', 'SELL', 'CLOSE'
            price REAL NOT NULL,
            reason TEXT,                         -- Why signal was generated
            indicators JSON,                     -- Indicator values at signal time
            timestamp TEXT NOT NULL,
            executed BOOLEAN DEFAULT 0,          -- Was this signal acted upon?
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # Table for tracking actual trades executed
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS strategy_trades (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            symbol TEXT NOT NULL,
            strategy_type TEXT NOT NULL,
            exchange TEXT NOT NULL,
            side TEXT NOT NULL,                  -- 'BUY' or 'SELL' (for entry), 'long' or 'short' (for position)
            order_type TEXT NOT NULL,            -- 'MARKET', 'LIMIT', etc.
            quantity REAL NOT NULL,
            price REAL NOT NULL,                 -- Entry price
            exit_price REAL,                     -- Exit price (for closed positions)
            order_id TEXT,                       -- Exchange order ID
            status TEXT NOT NULL,                -- 'FILLED', 'PARTIAL', 'CANCELLED'
            fee REAL,                            -- Trading fee
            fee_currency TEXT,
            pnl REAL,                            -- Realized PnL for closing trades
            timestamp TEXT NOT NULL,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # Table for tracking strategy performance metrics
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS strategy_metrics (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            symbol TEXT NOT NULL,
            strategy_type TEXT NOT NULL,
            metric_type TEXT NOT NULL,           -- 'daily_pnl', 'win_rate', etc.
            metric_value REAL NOT NULL,
            details JSON,                        -- Additional metric data
            timestamp TEXT NOT NULL,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # Create indexes for better query performance
    cursor.execute('CREATE INDEX IF NOT EXISTS idx_signals_symbol ON strategy_signals(symbol, timestamp)')
    cursor.execute('CREATE INDEX IF NOT EXISTS idx_trades_symbol ON strategy_trades(symbol, timestamp)')
    cursor.execute('CREATE INDEX IF NOT EXISTS idx_metrics_symbol ON strategy_metrics(symbol, timestamp)')
    
    conn.commit()
    conn.close()
    logger.info(f"Strategy database initialized at {DB_PATH}")


def save_strategy(symbol: str, strategy_type: str, exchange: str, config: Dict[str, Any]):
    """Save or update a strategy in the database"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        now = datetime.utcnow().isoformat()
        config_json = json.dumps(config)
        
        cursor.execute('''
            INSERT OR REPLACE INTO active_strategies 
            (symbol, strategy_type, exchange, config, started_at, last_active, status)
            VALUES (?, ?, ?, ?, 
                COALESCE((SELECT started_at FROM active_strategies WHERE symbol = ?), ?),
                ?, 'running')
        ''', (symbol, strategy_type, exchange, config_json, symbol, now, now))
        
        conn.commit()
        conn.close()
        logger.info(f"Saved strategy: {symbol} ({strategy_type})")
        return True
    except Exception as e:
        logger.error(f"Failed to save strategy {symbol}: {e}")
        return False


def remove_strategy(symbol: str, reason: str = "stopped", pnl: float = None, trades_count: int = None):
    """Remove a strategy and save to history"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # Get strategy info before removing
        cursor.execute('SELECT * FROM active_strategies WHERE symbol = ?', (symbol,))
        row = cursor.fetchone()
        
        if row:
            # Save to history
            stopped_at = datetime.utcnow().isoformat()
            cursor.execute('''
                INSERT INTO strategy_history 
                (symbol, strategy_type, exchange, started_at, stopped_at, reason, pnl, trades_count)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (row[1], row[2], row[3], row[5], stopped_at, reason, pnl, trades_count))
            
            # Remove from active
            cursor.execute('DELETE FROM active_strategies WHERE symbol = ?', (symbol,))
            
            conn.commit()
            logger.info(f"Removed strategy: {symbol} (reason: {reason})")
        
        conn.close()
        return True
    except Exception as e:
        logger.error(f"Failed to remove strategy {symbol}: {e}")
        return False


def get_active_strategies() -> List[Dict[str, Any]]:
    """Get all active strategies that should be restored"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute('SELECT symbol, strategy_type, exchange, config, started_at FROM active_strategies WHERE status = "running"')
        rows = cursor.fetchall()
        
        strategies = []
        for row in rows:
            strategies.append({
                'symbol': row[0],
                'strategy_type': row[1],
                'exchange': row[2],
                'config': json.loads(row[3]),
                'started_at': row[4]
            })
        
        conn.close()
        logger.info(f"Retrieved {len(strategies)} active strategies from database")
        return strategies
    except Exception as e:
        logger.error(f"Failed to get active strategies: {e}")
        return []


def update_last_active(symbol: str):
    """Update the last active timestamp for a strategy"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        now = datetime.utcnow().isoformat()
        cursor.execute('UPDATE active_strategies SET last_active = ? WHERE symbol = ?', (now, symbol))
        
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        logger.error(f"Failed to update last active for {symbol}: {e}")
        return False


def clear_all_strategies():
    """Clear all active strategies (for maintenance/debugging)"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute('DELETE FROM active_strategies')
        
        conn.commit()
        conn.close()
        logger.info("Cleared all active strategies")
        return True
    except Exception as e:
        logger.error(f"Failed to clear strategies: {e}")
        return False


def get_strategy_history(limit: int = 100) -> List[Dict[str, Any]]:
    """Get strategy execution history"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT symbol, strategy_type, exchange, started_at, stopped_at, reason, pnl, trades_count
            FROM strategy_history
            ORDER BY stopped_at DESC
            LIMIT ?
        ''', (limit,))
        
        rows = cursor.fetchall()
        
        history = []
        for row in rows:
            history.append({
                'symbol': row[0],
                'strategy_type': row[1],
                'exchange': row[2],
                'started_at': row[3],
                'stopped_at': row[4],
                'reason': row[5],
                'pnl': row[6],
                'trades_count': row[7]
            })
        
        conn.close()
        return history
    except Exception as e:
        logger.error(f"Failed to get strategy history: {e}")
        return []


def save_signal(symbol: str, strategy_type: str, signal_type: str, price: float, 
                reason: str = None, indicators: Dict[str, Any] = None):
    """Save a trading signal generated by a strategy"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        now = datetime.utcnow().isoformat()
        indicators_json = json.dumps(indicators) if indicators else None
        
        cursor.execute('''
            INSERT INTO strategy_signals 
            (symbol, strategy_type, signal_type, price, reason, indicators, timestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (symbol, strategy_type, signal_type, price, reason, indicators_json, now))
        
        conn.commit()
        conn.close()
        logger.info(f"Saved signal: {symbol} {signal_type} @ ${price}")
        return cursor.lastrowid
    except Exception as e:
        logger.error(f"Failed to save signal for {symbol}: {e}")
        return None


def save_trade(symbol: str, strategy_type: str, exchange: str, side: str, 
               order_type: str, quantity: float, price: float, 
               order_id: str = None, status: str = 'FILLED', 
               fee: float = None, fee_currency: str = None, pnl: float = None,
               exit_price: float = None, entry_time: int = None, exit_time: int = None):
    """Save a trade executed by a strategy
    
    Args:
        price: Entry price for the position (or exit price if exit_price is None)
        exit_price: Exit price for closing the position (optional)
        entry_time: Entry timestamp in milliseconds (optional)
        exit_time: Exit timestamp in milliseconds (optional)
        pnl: Realized P&L for closing trades
    """
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        now = datetime.utcnow().isoformat()
        
        cursor.execute('''
            INSERT INTO strategy_trades 
            (symbol, strategy_type, exchange, side, order_type, quantity, price, 
             exit_price, order_id, status, fee, fee_currency, pnl, timestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (symbol, strategy_type, exchange, side, order_type, quantity, price, 
              exit_price, order_id, status, fee, fee_currency, pnl, now))
        
        conn.commit()
        trade_id = cursor.lastrowid
        conn.close()
        
        if exit_price and pnl is not None:
            logger.info(f"Saved CLOSED trade: {symbol} {side} {quantity} @ ${price} â†’ ${exit_price} | P&L: ${pnl:.2f}")
        else:
            logger.info(f"Saved OPEN trade: {symbol} {side} {quantity} @ ${price}")
        
        return trade_id
    except Exception as e:
        logger.error(f"Failed to save trade for {symbol}: {e}")
        return None


def save_metric(symbol: str, strategy_type: str, metric_type: str, 
                metric_value: float, details: Dict[str, Any] = None):
    """Save a performance metric for a strategy"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        now = datetime.utcnow().isoformat()
        details_json = json.dumps(details) if details else None
        
        cursor.execute('''
            INSERT INTO strategy_metrics 
            (symbol, strategy_type, metric_type, metric_value, details, timestamp)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (symbol, strategy_type, metric_type, metric_value, details_json, now))
        
        conn.commit()
        conn.close()
        return cursor.lastrowid
    except Exception as e:
        logger.error(f"Failed to save metric for {symbol}: {e}")
        return None


def get_strategy_signals(symbol: str = None, limit: int = 100) -> List[Dict[str, Any]]:
    """Get signals generated by strategies"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        if symbol:
            cursor.execute('''
                SELECT symbol, strategy_type, signal_type, price, reason, indicators, timestamp, executed
                FROM strategy_signals
                WHERE symbol = ?
                ORDER BY timestamp DESC
                LIMIT ?
            ''', (symbol, limit))
        else:
            cursor.execute('''
                SELECT symbol, strategy_type, signal_type, price, reason, indicators, timestamp, executed
                FROM strategy_signals
                ORDER BY timestamp DESC
                LIMIT ?
            ''', (limit,))
        
        rows = cursor.fetchall()
        
        signals = []
        for row in rows:
            signals.append({
                'symbol': row[0],
                'strategy_type': row[1],
                'signal_type': row[2],
                'price': row[3],
                'reason': row[4],
                'indicators': json.loads(row[5]) if row[5] else None,
                'timestamp': row[6],
                'executed': bool(row[7])
            })
        
        conn.close()
        return signals
    except Exception as e:
        logger.error(f"Failed to get signals: {e}")
        return []


def get_strategy_trades(symbol: str = None, limit: int = 100, include_open: bool = True) -> List[Dict[str, Any]]:
    """Get trades executed by strategies
    
    Args:
        symbol: Filter by symbol (optional)
        limit: Maximum number of trades to return
        include_open: Include trades without exit_price (open positions)
    
    Returns:
        List of trade dictionaries with full details
    """
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # Build query based on filters
        query = '''
            SELECT symbol, strategy_type, exchange, side, order_type, quantity, price, 
                   exit_price, order_id, status, fee, fee_currency, pnl, timestamp
            FROM strategy_trades
        '''
        
        conditions = []
        params = []
        
        if symbol:
            conditions.append('symbol = ?')
            params.append(symbol)
        
        if not include_open:
            conditions.append('exit_price IS NOT NULL')
        
        if conditions:
            query += ' WHERE ' + ' AND '.join(conditions)
        
        query += ' ORDER BY timestamp DESC LIMIT ?'
        params.append(limit)
        
        cursor.execute(query, params)
        rows = cursor.fetchall()
        
        trades = []
        for row in rows:
            trade = {
                'symbol': row[0],
                'strategy_type': row[1],
                'exchange': row[2],
                'side': row[3],
                'order_type': row[4],
                'quantity': row[5],
                'entry_price': row[6],  # Renamed from 'price' for clarity
                'exit_price': row[7],
                'order_id': row[8],
                'status': row[9],
                'fee': row[10],
                'fee_currency': row[11],
                'pnl': row[12],
                'timestamp': row[13],
                # Calculate P&L percentage if we have exit price
                'pnl_pct': None
            }
            
            # Calculate P&L percentage for closed trades
            if trade['exit_price'] and trade['pnl'] is not None and trade['entry_price'] > 0:
                if trade['side'] in ['long', 'BUY']:
                    trade['pnl_pct'] = ((trade['exit_price'] - trade['entry_price']) / trade['entry_price']) * 100
                elif trade['side'] in ['short', 'SELL']:
                    trade['pnl_pct'] = ((trade['entry_price'] - trade['exit_price']) / trade['entry_price']) * 100
            
            trades.append(trade)
        
        conn.close()
        return trades
    except Exception as e:
        logger.error(f"Failed to get trades: {e}")
        return []


def get_strategy_performance(symbol: str) -> Dict[str, Any]:
    """Get comprehensive performance stats for a strategy"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # Get trade stats
        cursor.execute('''
            SELECT 
                COUNT(*) as total_trades,
                SUM(CASE WHEN side = 'BUY' THEN 1 ELSE 0 END) as buy_count,
                SUM(CASE WHEN side = 'SELL' THEN 1 ELSE 0 END) as sell_count,
                SUM(CASE WHEN pnl > 0 THEN 1 ELSE 0 END) as winning_trades,
                SUM(CASE WHEN pnl < 0 THEN 1 ELSE 0 END) as losing_trades,
                SUM(pnl) as total_pnl,
                AVG(pnl) as avg_pnl,
                MAX(pnl) as max_win,
                MIN(pnl) as max_loss,
                SUM(fee) as total_fees
            FROM strategy_trades
            WHERE symbol = ? AND pnl IS NOT NULL
        ''', (symbol,))
        
        trade_stats = cursor.fetchone()
        
        # Get signal stats
        cursor.execute('''
            SELECT 
                COUNT(*) as total_signals,
                SUM(CASE WHEN executed = 1 THEN 1 ELSE 0 END) as executed_signals
            FROM strategy_signals
            WHERE symbol = ?
        ''', (symbol,))
        
        signal_stats = cursor.fetchone()
        
        conn.close()
        
        total_trades = trade_stats[0] or 0
        winning_trades = trade_stats[3] or 0
        
        return {
            'symbol': symbol,
            'total_trades': total_trades,
            'buy_count': trade_stats[1] or 0,
            'sell_count': trade_stats[2] or 0,
            'winning_trades': winning_trades,
            'losing_trades': trade_stats[4] or 0,
            'win_rate': (winning_trades / total_trades * 100) if total_trades > 0 else 0,
            'total_pnl': trade_stats[5] or 0,
            'avg_pnl': trade_stats[6] or 0,
            'max_win': trade_stats[7] or 0,
            'max_loss': trade_stats[8] or 0,
            'total_fees': trade_stats[9] or 0,
            'total_signals': signal_stats[0] or 0,
            'executed_signals': signal_stats[1] or 0,
            'signal_execution_rate': (signal_stats[1] / signal_stats[0] * 100) if signal_stats[0] > 0 else 0
        }
    except Exception as e:
        logger.error(f"Failed to get performance for {symbol}: {e}")
        return {}


def get_recent_signals_from_db(limit: int = 20):
    """Get recent signals for dashboard display (returns raw tuples for performance)"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT id, symbol, strategy_type, signal_type, price, reason, timestamp
            FROM strategy_signals
            ORDER BY timestamp DESC
            LIMIT ?
        ''', (limit,))
        
        rows = cursor.fetchall()
        conn.close()
        return rows
    except Exception as e:
        logger.error(f"Failed to get recent signals: {e}")
        return []


def get_recent_trades_from_db(limit: int = 20):
    """Get recent trades for dashboard display (returns raw tuples for performance)"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT id, symbol, strategy_type, side, quantity, price, status, pnl, timestamp
            FROM strategy_trades
            ORDER BY timestamp DESC
            LIMIT ?
        ''', (limit,))
        
        rows = cursor.fetchall()
        conn.close()
        return rows
    except Exception as e:
        logger.error(f"Failed to get recent trades: {e}")
        return []


# Initialize database on module import
init_db()
